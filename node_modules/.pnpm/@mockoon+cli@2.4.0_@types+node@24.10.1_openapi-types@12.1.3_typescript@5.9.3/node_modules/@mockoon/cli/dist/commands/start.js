"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const jsonfile_1 = require("jsonfile");
const path_1 = require("path");
const util_1 = require("util");
const config_1 = require("../config");
const command_constants_1 = require("../constants/command.constants");
const messages_constants_1 = require("../constants/messages.constants");
const data_1 = require("../libs/data");
const process_manager_1 = require("../libs/process-manager");
const server_1 = require("../libs/server");
const utils_1 = require("../libs/utils");
class Start extends command_1.Command {
    async run() {
        const { flags: userFlags } = this.parse(Start);
        let environmentsInfo = [];
        try {
            // We are in a container, env file is ready and relative to the Dockerfile
            if (userFlags.container) {
                environmentsInfo = await this.getEnvInfoListFromContainerFlag(userFlags);
            }
            else {
                const parsedEnvironments = await (0, data_1.parseDataFiles)(userFlags.data);
                userFlags.data = parsedEnvironments.filePaths;
                environmentsInfo = await this.getEnvironmentsInfo(userFlags, parsedEnvironments.environments);
            }
            for (const environmentInfo of environmentsInfo) {
                await this.validatePort(environmentInfo.port, environmentInfo.hostname);
                await this.validateName(environmentInfo.name);
                if (userFlags['daemon-off']) {
                    this.startForegroundProcess(environmentInfo);
                }
                else {
                    await this.startManagedProcess(environmentInfo);
                }
            }
        }
        catch (error) {
            this.error(error.message);
        }
        finally {
            process_manager_1.ProcessManager.disconnect();
        }
    }
    async addProcessToProcessListManager(environmentInfo, process) {
        await process_manager_1.ProcessListManager.addProcess({
            name: environmentInfo.name,
            port: environmentInfo.port,
            hostname: environmentInfo.hostname,
            endpointPrefix: environmentInfo.endpointPrefix,
            pid: process[0].pm2_env.pm_id
        });
    }
    logStartedProcess(environmentInfo, process) {
        const hostname = !environmentInfo.hostname
            ? 'localhost'
            : environmentInfo.hostname;
        this.log(messages_constants_1.Messages.CLI.PROCESS_STARTED, environmentInfo.protocol, hostname, environmentInfo.port, process[0].pm2_env.pm_id, process[0].pm2_env.name);
    }
    /**
     * Start the mock server and run it in the same process in the foreground.
     * We don't use PM2 here to manage the process
     *
     * @param environmentInfo
     * @returns
     */
    startForegroundProcess(environmentInfo) {
        const parameters = {
            data: environmentInfo.dataFile,
            environmentDir: environmentInfo.initialDataDir
                ? environmentInfo.initialDataDir
                : '',
            logTransaction: environmentInfo.logTransaction,
            fileTransportsOptions: [
                { filename: (0, path_1.join)(config_1.Config.logsPath, `${environmentInfo.name}-out.log`) }
            ]
        };
        (0, server_1.createServer)(parameters);
    }
    /**
     * Start the mock server and manage the process with PM2
     *
     * @param environmentInfo
     * @returns
     */
    async startManagedProcess(environmentInfo) {
        const args = ['--data', environmentInfo.dataFile];
        if (environmentInfo.initialDataDir) {
            args.push('--environmentDir', environmentInfo.initialDataDir);
        }
        if (environmentInfo.logTransaction) {
            args.push('--logTransaction');
        }
        const process = await process_manager_1.ProcessManager.start({
            max_restarts: 1,
            wait_ready: true,
            min_uptime: 10000,
            kill_timeout: 2000,
            args,
            error: (0, path_1.join)(config_1.Config.logsPath, `${environmentInfo.name}-error.log`),
            output: (0, path_1.join)(config_1.Config.logsPath, `${environmentInfo.name}-out.log`),
            name: environmentInfo.name,
            script: (0, path_1.resolve)(__dirname, '../libs/server-start-script.js'),
            exec_mode: 'fork'
        });
        if (process[0].pm2_env.status === 'errored') {
            // if process is errored we want to delete it
            await this.handleProcessError(environmentInfo.name);
        }
        this.logStartedProcess(environmentInfo, process);
        await this.addProcessToProcessListManager(environmentInfo, process);
    }
    async handleProcessError(name) {
        // if process is errored we want to delete it
        await process_manager_1.ProcessManager.delete(name);
        this.error((0, util_1.format)(messages_constants_1.Messages.CLI.PROCESS_START_LOG_ERROR, name, name));
    }
    async getEnvInfoListFromContainerFlag(userFlags) {
        const environmentsInfo = [];
        for (const dataFile of userFlags.data) {
            const environment = await (0, jsonfile_1.readFile)(dataFile, 'utf-8');
            let protocol = 'http';
            if (environment.tlsOptions.enabled) {
                protocol = 'https';
            }
            environmentsInfo.push({
                protocol,
                dataFile,
                name: environment.name,
                hostname: environment.hostname,
                port: environment.port,
                endpointPrefix: environment.endpointPrefix,
                initialDataDir: null,
                logTransaction: userFlags['log-transaction']
            });
        }
        return environmentsInfo;
    }
    async getEnvironmentsInfo(userFlags, environments) {
        const environmentsInfo = [];
        for (let envIndex = 0; envIndex < environments.length; envIndex++) {
            try {
                const environmentInfo = await (0, data_1.prepareEnvironment)({
                    environment: environments[envIndex],
                    userOptions: {
                        hostname: userFlags.hostname[envIndex],
                        pname: userFlags.pname[envIndex],
                        port: userFlags.port[envIndex]
                    },
                    repair: userFlags.repair
                });
                environmentsInfo.push(Object.assign(Object.assign({}, environmentInfo), { initialDataDir: (0, utils_1.getDirname)(userFlags.data[envIndex]), logTransaction: userFlags['log-transaction'] }));
            }
            catch (error) {
                this.error(error.message);
            }
        }
        return environmentsInfo;
    }
    async validateName(name) {
        const runningProcesses = await process_manager_1.ProcessManager.list();
        const processNamesList = runningProcesses.map((process) => process.name);
        if (processNamesList.includes(name)) {
            this.error((0, util_1.format)(messages_constants_1.Messages.CLI.PROCESS_NAME_USED_ERROR, name));
        }
    }
    async validatePort(port, hostname) {
        if (!(0, utils_1.portIsValid)(port)) {
            this.error((0, util_1.format)(messages_constants_1.Messages.CLI.PORT_IS_NOT_VALID, port));
        }
        if (await (0, utils_1.portInUse)(port, hostname)) {
            this.error((0, util_1.format)(messages_constants_1.Messages.CLI.PORT_ALREADY_USED, port));
        }
    }
}
exports.default = Start;
Start.description = 'Start one or more mock API';
Start.examples = [
    '$ mockoon-cli start --data ~/data.json',
    '$ mockoon-cli start --data ~/data1.json ~/data2.json --port 3000 3001 --pname mock1 mock2 --hostname 127.0.0.1 192.168.1.1',
    '$ mockoon-cli start --data https://file-server/data.json',
    '$ mockoon-cli start --data ~/data.json --pname "proc1"',
    '$ mockoon-cli start --data ~/data.json --daemon-off',
    '$ mockoon-cli start --data ~/data.json --log-transaction'
];
Start.flags = Object.assign(Object.assign(Object.assign({}, command_constants_1.commonFlags), command_constants_1.startFlags), { pname: command_1.flags.string({
        char: 'N',
        description: 'Override the process(es) name(s)',
        multiple: true,
        default: []
    }), hostname: command_1.flags.string({
        char: 'l',
        description: 'Listening hostname(s)',
        multiple: true,
        default: []
    }), 'daemon-off': command_1.flags.boolean({
        char: 'D',
        description: 'Keep the CLI in the foreground and do not manage the process with PM2',
        default: false
    }), 
    /**
     * /!\ Undocumented flag.
     * Mostly for internal use when `start `command is called during
     * a Docker image build.
     *
     * When using the `dockerize` command, file loading, validity checks,
     * migrations, etc. are all performed, and the single environment is
     * extracted in a separated file next to the generated Dockerfile.
     * It's easier to directly provide this file to the `start` command run
     * from the Dockerfile when building the Docker image rather than
     * having the image build failing due to a failure in the `start` command.
     */
    container: command_1.flags.boolean({
        char: 'c',
        hidden: true
    }) });
//# sourceMappingURL=start.js.map