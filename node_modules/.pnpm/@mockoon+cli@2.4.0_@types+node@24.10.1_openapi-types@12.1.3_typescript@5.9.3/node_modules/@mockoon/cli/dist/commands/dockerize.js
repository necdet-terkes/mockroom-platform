"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const fs_1 = require("fs");
const mkdirp = require("mkdirp");
const mustache_1 = require("mustache");
const path_1 = require("path");
const util_1 = require("util");
const config_1 = require("../config");
const command_constants_1 = require("../constants/command.constants");
const docker_constants_1 = require("../constants/docker.constants");
const messages_constants_1 = require("../constants/messages.constants");
const data_1 = require("../libs/data");
const utils_1 = require("../libs/utils");
class Dockerize extends command_1.Command {
    async run() {
        const { flags: userFlags } = this.parse(Dockerize);
        const resolvedDockerfilePath = (0, path_1.resolve)(userFlags.output);
        const dockerfilePath = (0, path_1.parse)(resolvedDockerfilePath);
        const parsedEnvironments = await (0, data_1.parseDataFiles)(userFlags.data);
        userFlags.data = parsedEnvironments.filePaths;
        const environmentsInfo = [];
        try {
            for (let envIndex = 0; envIndex < parsedEnvironments.environments.length; envIndex++) {
                const environmentInfo = await (0, data_1.prepareEnvironment)({
                    environment: parsedEnvironments.environments[envIndex],
                    userOptions: {
                        port: userFlags.port[envIndex]
                    },
                    dockerfileDir: dockerfilePath.dir,
                    repair: userFlags.repair
                });
                environmentsInfo.push(environmentInfo);
                if (!(0, utils_1.portIsValid)(environmentInfo.port)) {
                    this.error((0, util_1.format)(messages_constants_1.Messages.CLI.PORT_IS_NOT_VALID, environmentInfo.port));
                }
            }
            const dockerFile = (0, mustache_1.render)(docker_constants_1.DOCKER_TEMPLATE, {
                ports: environmentsInfo.map((environmentInfo) => environmentInfo.port),
                filePaths: environmentsInfo.map((environmentInfo) => (0, path_1.parse)(environmentInfo.dataFile).base),
                version: config_1.Config.version,
                // passing more args to the dockerfile template, only make sense for log transaction yet as other flags are immediately used during the file creation and data preparation
                args: userFlags['log-transaction'] ? ', "--log-transaction"' : ''
            });
            await mkdirp(dockerfilePath.dir);
            await fs_1.promises.writeFile(resolvedDockerfilePath, dockerFile);
            this.log(messages_constants_1.Messages.CLI.DOCKERIZE_SUCCESS, resolvedDockerfilePath);
            this.log(messages_constants_1.Messages.CLI.DOCKERIZE_BUILD_COMMAND, dockerfilePath.dir, environmentsInfo.length > 1
                ? 'mockoon-mocks'
                : environmentsInfo[0].name, environmentsInfo.reduce((portsString, environmentInfo) => `${portsString ? portsString + ' ' : portsString}-p ${environmentInfo.port}:${environmentInfo.port}`, ''), environmentsInfo.length > 1 ? 'mockoon-mocks' : environmentsInfo[0].name);
        }
        catch (error) {
            this.error(error.message);
        }
    }
}
exports.default = Dockerize;
Dockerize.description = 'Create a Dockerfile to build a self-contained image of one or more mock API';
Dockerize.examples = [
    '$ mockoon-cli dockerize --data ~/data.json --output ./Dockerfile',
    '$ mockoon-cli dockerize --data ~/data1.json ~/data2.json --output ./Dockerfile',
    '$ mockoon-cli dockerize --data https://file-server/data.json --output ./Dockerfile'
];
Dockerize.flags = Object.assign(Object.assign(Object.assign({}, command_constants_1.commonFlags), command_constants_1.startFlags), { output: command_1.flags.string({
        char: 'o',
        description: 'Generated Dockerfile path and name (e.g. `./Dockerfile`)',
        required: true
    }) });
//# sourceMappingURL=dockerize.js.map