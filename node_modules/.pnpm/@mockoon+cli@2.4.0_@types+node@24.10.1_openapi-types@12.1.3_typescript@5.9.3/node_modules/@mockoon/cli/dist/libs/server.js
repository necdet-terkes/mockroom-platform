"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServer = void 0;
const commons_1 = require("@mockoon/commons");
const commons_server_1 = require("@mockoon/commons-server");
const jsonfile_1 = require("jsonfile");
const util_1 = require("util");
const winston_1 = require("winston");
const messages_constants_1 = require("../constants/messages.constants");
let logger;
const createLoggerInstance = (fileTransportsOptions) => {
    const transportsInstances = [new winston_1.transports.Console()];
    if (fileTransportsOptions === null || fileTransportsOptions === void 0 ? void 0 : fileTransportsOptions.length) {
        fileTransportsOptions.forEach((fileTransportOption) => {
            transportsInstances.push(new winston_1.transports.File(fileTransportOption));
        });
    }
    logger = (0, winston_1.createLogger)({
        level: 'info',
        format: winston_1.format.combine(winston_1.format.timestamp(), winston_1.format.json()),
        transports: transportsInstances
    });
};
const addEventListeners = function (server, environment, logTransaction) {
    const logMeta = { mockName: environment.name };
    server.on('started', () => {
        logger.info((0, util_1.format)(messages_constants_1.Messages.SERVER.STARTED, environment.port), logMeta);
        if (!!process.send) {
            process.send('ready');
        }
    });
    server.on('error', (errorCode, error) => {
        // throw blocking errors
        if (errorCode === commons_1.ServerErrorCodes.PORT_ALREADY_USED ||
            errorCode === commons_1.ServerErrorCodes.PORT_INVALID ||
            errorCode === commons_1.ServerErrorCodes.UNKNOWN_SERVER_ERROR ||
            errorCode === commons_1.ServerErrorCodes.CERT_FILE_NOT_FOUND) {
            throw new Error(commons_1.CommonsTexts.EN.MESSAGES[errorCode]);
        }
        // report non blocking errors
        if ([
            commons_1.ServerErrorCodes.REQUEST_BODY_PARSE,
            commons_1.ServerErrorCodes.ROUTE_FILE_SERVING_ERROR,
            commons_1.ServerErrorCodes.ROUTE_SERVING_ERROR,
            commons_1.ServerErrorCodes.ROUTE_CREATION_ERROR,
            commons_1.ServerErrorCodes.ROUTE_CREATION_ERROR_REGEX,
            commons_1.ServerErrorCodes.PROXY_ERROR
        ].indexOf(errorCode) > -1) {
            logger.error((error === null || error === void 0 ? void 0 : error.message) || '', logMeta);
        }
    });
    server.on('creating-proxy', () => {
        logger.info((0, util_1.format)(messages_constants_1.Messages.SERVER.CREATING_PROXY, environment.proxyHost), logMeta);
    });
    server.on('transaction-complete', (transaction) => {
        transaction.request.method =
            transaction.request.method.toUpperCase();
        if (logTransaction) {
            logMeta.transaction = transaction;
        }
        logger.info(`${transaction.request.method.toUpperCase()} ${transaction.request.urlPath} | ${transaction.response.statusCode}${transaction.proxied ? ' | proxied' : ''}`, logMeta);
    });
    server.on('stopped', () => {
        logger.info(messages_constants_1.Messages.SERVER.STOPPED, logMeta);
    });
    process.on('SIGINT', () => {
        server.stop();
    });
};
const createServer = (parameters) => {
    try {
        createLoggerInstance(parameters.fileTransportsOptions);
        const environment = (0, jsonfile_1.readFileSync)(parameters.data);
        const server = new commons_server_1.MockoonServer(environment, {
            logProvider: () => ({
                log: logger.log.bind(logger),
                debug: logger.debug.bind(logger),
                info: logger.info.bind(logger),
                warn: logger.warn.bind(logger),
                error: logger.error.bind(logger)
            }),
            environmentDirectory: parameters.environmentDir
        });
        addEventListeners(server, environment, parameters.logTransaction);
        server.start();
    }
    catch (error) {
        throw new Error(error.message);
    }
};
exports.createServer = createServer;
//# sourceMappingURL=server.js.map