"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanDataFiles = exports.prepareEnvironment = exports.parseDataFiles = void 0;
const commons_1 = require("@mockoon/commons");
const commons_server_1 = require("@mockoon/commons-server");
const axios_1 = require("axios");
const fs_1 = require("fs");
const inquirer_1 = require("inquirer");
const mkdirp = require("mkdirp");
const path_1 = require("path");
const config_1 = require("../config");
const messages_constants_1 = require("../constants/messages.constants");
const utils_1 = require("./utils");
/**
 * Load and parse a JSON data file.
 * Supports both legacy export files (with one or multiple envs) or new environment files.
 * If a legacy export is encountered, unwrap it and update `--data` flag to reflect the number of environments unwrapped
 *
 * @param filePath
 */
const parseDataFiles = async (filePaths) => {
    const openAPIConverter = new commons_server_1.OpenAPIConverter();
    let environments = [];
    let newFilePaths = [];
    let filePathIndex = 0;
    for (const filePath of filePaths) {
        try {
            const environment = await openAPIConverter.convertFromOpenAPI(filePath);
            if (environment) {
                environments.push(environment);
                newFilePaths.push(filePath);
            }
        }
        catch (openAPIError) {
            try {
                let data;
                if (filePath.startsWith('http')) {
                    data = (await axios_1.default.get(filePath, { timeout: 30000 })).data;
                }
                else {
                    data = await fs_1.promises.readFile(filePath, { encoding: 'utf-8' });
                }
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }
                if ((0, commons_1.IsLegacyExportData)(data)) {
                    const unwrappedExport = (0, commons_1.UnwrapLegacyExport)(data);
                    // Extract all environments, eventually filter items of type 'route'
                    environments = [...environments, ...unwrappedExport];
                    // if we unwrapped more than one exported environment, add as many `--data` flag entries
                    if (unwrappedExport.length >= 1) {
                        newFilePaths = [
                            ...newFilePaths,
                            ...new Array(unwrappedExport.length).fill(filePath)
                        ];
                    }
                }
                else if (typeof data === 'object') {
                    environments.push(data);
                    newFilePaths.push(filePath);
                }
            }
            catch (JSONError) {
                throw new Error(`${messages_constants_1.Messages.CLI.DATA_INVALID}: ${JSONError.message}`);
            }
        }
        filePathIndex++;
    }
    if (environments.length === 0) {
        throw new Error(messages_constants_1.Messages.CLI.ENVIRONMENT_NOT_AVAILABLE_ERROR);
    }
    return { filePaths: newFilePaths, environments };
};
exports.parseDataFiles = parseDataFiles;
/**
 * Check if an environment can be run by the CLI and
 * migrate it if needed.
 * Validate the environment schema (will automatically repair)
 *
 * @param environment
 */
const migrateAndValidateEnvironment = async (environment, forceRepair) => {
    // environment data are too old: lastMigration is not present
    if (environment.lastMigration === undefined && !forceRepair) {
        const promptResponse = await (0, inquirer_1.prompt)([
            {
                name: 'repair',
                message: `${environment.name ? '"' + environment.name + '"' : 'This environment'} does not seem to be a valid Mockoon environment or is too old. Let Mockoon attempt to repair it?`,
                type: 'confirm',
                default: true
            }
        ]);
        if (!promptResponse.repair) {
            throw new Error(messages_constants_1.Messages.CLI.DATA_TOO_OLD_ERROR);
        }
    }
    // environment data migrated with a more recent version (if installed CLI version does not include @mockoon/commons with required migrations)
    if (environment.lastMigration > commons_1.HighestMigrationId) {
        throw new Error(messages_constants_1.Messages.CLI.DATA_TOO_RECENT_ERROR);
    }
    try {
        // apply migrations
        commons_1.Migrations.forEach((migration) => {
            if (migration.id > environment.lastMigration) {
                migration.migrationFunction(environment);
            }
        });
    }
    catch (error) {
        environment.lastMigration = commons_1.HighestMigrationId;
    }
    let validatedEnvironment = commons_1.EnvironmentSchema.validate(environment).value;
    if (!validatedEnvironment) {
        throw new Error(messages_constants_1.Messages.CLI.DATA_INVALID);
    }
    validatedEnvironment = (0, commons_1.repairRefs)(validatedEnvironment);
    return validatedEnvironment;
};
/**
 * Migrate the environment
 * Copy the environment to a new temporary file.
 *
 * @param environments - path to the data file or export data
 * @param options
 */
const prepareEnvironment = async (params) => {
    params.environment = await migrateAndValidateEnvironment(params.environment, params.repair);
    // transform the provided name or env's name to be used as process name
    params.environment.name = (0, utils_1.transformEnvironmentName)(params.userOptions.pname || params.environment.name);
    if (params.userOptions.port !== undefined) {
        params.environment.port = params.userOptions.port;
    }
    if (params.userOptions.hostname !== undefined) {
        params.environment.hostname = params.userOptions.hostname;
    }
    let dataFile = (0, path_1.join)(config_1.Config.dataPath, `${params.environment.name}.json`);
    // if we are building a Dockerfile, we want the data in the same folder
    if (params.dockerfileDir) {
        await mkdirp(params.dockerfileDir);
        dataFile = `${params.dockerfileDir}/${params.environment.name}.json`;
    }
    // save environment to data path
    await fs_1.promises.writeFile(dataFile, JSON.stringify(params.environment));
    return {
        name: params.environment.name,
        protocol: params.environment.tlsOptions.enabled ? 'https' : 'http',
        hostname: params.environment.hostname,
        port: params.environment.port,
        endpointPrefix: params.environment.endpointPrefix,
        dataFile
    };
};
exports.prepareEnvironment = prepareEnvironment;
/**
 * Clean the temporary data files by deleting the ones with no
 * matching running process
 *
 * @param processes
 */
const cleanDataFiles = async (processes) => {
    const files = await fs_1.promises.readdir(config_1.Config.dataPath);
    files.forEach(async (file) => {
        if (processes.findIndex((process) => `${process.name}.json` === file) === -1) {
            await fs_1.promises.unlink((0, path_1.join)(config_1.Config.dataPath, file));
        }
    });
};
exports.cleanDataFiles = cleanDataFiles;
//# sourceMappingURL=data.js.map