"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildDemoEnvironment = exports.BuildEnvironment = exports.BuildDatabucket = exports.BuildRoute = exports.BuildFolder = exports.CloneRouteResponse = exports.BuildResponseRule = exports.BuildRouteResponse = exports.BuildHeader = void 0;
const uuid_1 = require("uuid");
const environment_schema_constants_1 = require("../constants/environment-schema.constants");
const utils_1 = require("../libs/utils");
const route_model_1 = require("../models/route.model");
/**
 * Build a new environment or route response header
 */
const BuildHeader = (key = '', value = '') => ({ key, value });
exports.BuildHeader = BuildHeader;
/**
 * Build a new route response
 */
const BuildRouteResponse = () => (Object.assign({}, environment_schema_constants_1.RouteResponseDefault));
exports.BuildRouteResponse = BuildRouteResponse;
/**
 * Build a new response rule
 */
const BuildResponseRule = () => (Object.assign({}, environment_schema_constants_1.ResponseRuleDefault));
exports.BuildResponseRule = BuildResponseRule;
/**
 * Clone a new route response with a fresh UUID
 */
const CloneRouteResponse = (routeResponse) => (Object.assign(Object.assign({}, (0, utils_1.CloneObject)(routeResponse)), { uuid: (0, uuid_1.v4)(), label: `${routeResponse.label} (copy)`, default: false }));
exports.CloneRouteResponse = CloneRouteResponse;
/**
 * Build a new folder object in the folder tree
 */
const BuildFolder = () => (Object.assign({}, environment_schema_constants_1.FolderDefault));
exports.BuildFolder = BuildFolder;
/**
 * Build a new route
 */
const BuildRoute = (type, hasDefaultRouteResponse = true) => {
    let defaultResponse = Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { default: true });
    if (type === route_model_1.RouteType.CRUD) {
        defaultResponse = Object.assign(Object.assign({}, defaultResponse), { bodyType: route_model_1.BodyTypes.DATABUCKET });
    }
    return Object.assign(Object.assign({}, environment_schema_constants_1.RouteDefault), { type, method: type === 'crud' ? '' : route_model_1.Methods.get, responses: hasDefaultRouteResponse ? [defaultResponse] : [] });
};
exports.BuildRoute = BuildRoute;
/**
 * Build a new databucket
 */
const BuildDatabucket = () => (Object.assign({}, environment_schema_constants_1.DataBucketDefault));
exports.BuildDatabucket = BuildDatabucket;
/**
 * Build a new environment
 */
const BuildEnvironment = (params = {
    hasDefaultRoute: true,
    hasDefaultHeader: true
}) => {
    const newRoute = (0, exports.BuildRoute)(route_model_1.RouteType.HTTP);
    return Object.assign(Object.assign({}, environment_schema_constants_1.EnvironmentDefault), { port: params.port !== undefined ? params.port : environment_schema_constants_1.EnvironmentDefault.port, routes: params.hasDefaultRoute ? [newRoute] : [], headers: params.hasDefaultHeader
            ? [(0, exports.BuildHeader)('Content-Type', 'application/json')]
            : [], proxyReqHeaders: [(0, exports.BuildHeader)()], proxyResHeaders: [(0, exports.BuildHeader)()], rootChildren: params.hasDefaultRoute
            ? [{ type: 'route', uuid: newRoute.uuid }]
            : [] });
};
exports.BuildEnvironment = BuildEnvironment;
/**
 * Build a demo environment when starting the application for the first time
 */
const BuildDemoEnvironment = () => {
    const databucket = (0, exports.BuildDatabucket)();
    const newRoutes = [
        Object.assign({}, (0, exports.BuildRoute)(route_model_1.RouteType.CRUD)),
        (0, exports.BuildRoute)(route_model_1.RouteType.HTTP),
        (0, exports.BuildRoute)(route_model_1.RouteType.HTTP),
        (0, exports.BuildRoute)(route_model_1.RouteType.HTTP),
        (0, exports.BuildRoute)(route_model_1.RouteType.HTTP),
        (0, exports.BuildRoute)(route_model_1.RouteType.HTTP)
    ];
    return Object.assign(Object.assign({}, (0, exports.BuildEnvironment)()), { name: 'Demo API', data: [
            Object.assign(Object.assign({}, databucket), { name: 'Users', value: '[\n  {{#repeat 50}}\n  {\n    "id": "{{faker \'datatype.uuid\'}}",\n    "username": "{{faker \'internet.userName\'}}"\n  }\n  {{/repeat}}\n]' })
        ], routes: [
            Object.assign(Object.assign({}, newRoutes[0]), { endpoint: 'users', documentation: 'Endpoint performing CRUD operations on a data bucket', responses: [
                    Object.assign(Object.assign({}, newRoutes[0].responses[0]), { databucketID: databucket.id })
                ] }),
            Object.assign(Object.assign({}, newRoutes[1]), { method: route_model_1.Methods.get, endpoint: 'template', documentation: 'Generate random body (JSON, text, CSV, etc) with templating', responses: [
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { label: "Creates 10 random users, or the amount specified in the 'total' query param", body: '{\n  "Templating example": "For more information about templating, click the blue \'i\' above this editor",\n  "users": [\n    {{# repeat (queryParam \'total\' \'10\') }}\n      {\n        "userId": "{{ faker \'datatype.number\' min=10000 max=100000 }}",\n        "firstname": "{{ faker \'name.firstName\' }}",\n        "lastname": "{{ faker \'name.lastName\' }}",\n        "friends": [\n          {{# repeat (faker \'datatype.number\' 5) }}\n            {\n              "id": "{{ faker \'datatype.uuid\' }}"\n            }\n          {{/ repeat }}\n        ]\n      },\n    {{/ repeat }}\n  ],\n  "total": "{{queryParam \'total\' \'10\'}}"\n}' })
                ] }),
            Object.assign(Object.assign({}, newRoutes[2]), { method: route_model_1.Methods.post, endpoint: 'content/:param1', documentation: 'Use multiple responses with rules', responses: [
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { label: 'Default response', body: '{\n  "Rules example": "Default response. Served if route param \'param1\' is not present."\n}' }),
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { label: 'Content XYZ', body: "{\n  \"Rules example\": \"Content XYZ. Served if route param 'param1' equals 'xyz'. (See in 'Rules' tab)\"\n}", rules: [
                            {
                                target: 'params',
                                modifier: 'param1',
                                value: 'xyz',
                                invert: false,
                                operator: 'equals'
                            }
                        ] }),
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { statusCode: 404, label: 'Content not found', body: "{\n  \"Rules example\": \"Content not found. Served if route param 'param1' is not equal to 'xyz'. (See in 'Rules' tab)\"\n}\n", rules: [
                            {
                                target: 'params',
                                modifier: 'param1',
                                value: '^(?!.*xyz).*$',
                                invert: false,
                                operator: 'regex'
                            }
                        ] })
                ] }),
            Object.assign(Object.assign({}, newRoutes[3]), { method: route_model_1.Methods.get, endpoint: 'file/:pageName', documentation: "Serve a file dynamically depending on the path param 'pageName'.", responses: [
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { label: 'Templating is also supported in file path', headers: [{ key: 'Content-Type', value: 'text/html' }], body: '', filePath: "./page{{urlParam 'pageName'}}.html" })
                ] }),
            Object.assign(Object.assign({}, newRoutes[4]), { method: route_model_1.Methods.put, endpoint: 'path/with/pattern(s)?/*', documentation: 'Path supports various patterns', responses: [
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { headers: [{ key: 'Content-Type', value: 'text/plain' }], body: "The current path will match the following routes: \nhttp://localhost:3000/path/with/pattern/\nhttp://localhost:3000/path/with/patterns/\nhttp://localhost:3000/path/with/patterns/anything-else\n\nLearn more about Mockoon's routing: https://mockoon.com/docs/latest/routing" })
                ] }),
            Object.assign(Object.assign({}, newRoutes[5]), { method: route_model_1.Methods.get, endpoint: 'forward-and-record', documentation: 'Can Mockoon forward or record entering requests?', responses: [
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { headers: [{ key: 'Content-Type', value: 'text/plain' }], body: "Mockoon can also act as a proxy and forward all entering requests that are not caught by declared routes. \nYou can activate this option in the environment settings ('cog' icon in the upper right corner). \nTo learn more: https://mockoon.com/docs/latest/proxy-mode\n\nAs always, all entering requests, and responses from the proxied server will be recorded ('clock' icon in the upper right corner).\nTo learn more: https://mockoon.com/docs/latest/requests-logging" })
                ] })
        ], rootChildren: newRoutes.map((route) => ({
            type: 'route',
            uuid: route.uuid
        })) });
};
exports.BuildDemoEnvironment = BuildDemoEnvironment;
//# sourceMappingURL=schema-builder.js.map