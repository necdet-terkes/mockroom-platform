"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Helpers = void 0;
const faker_1 = require("@faker-js/faker");
const date_fns_1 = require("date-fns");
const handlebars_1 = require("handlebars");
const os_1 = require("os");
const utils_1 = require("../utils");
/**
 * Handlebars may insert its own `options` object as the last argument.
 * Be careful when retrieving `defaultValue` or any other last param.
 *
 * use:
 * if (typeof defaultValue === 'object') {
 *   defaultValue = '';
 * }
 *
 * or:
 * args[args.length - 1]
 */
exports.Helpers = {
    repeat: function (...args) {
        let content = '';
        let count = 0;
        const options = args[args.length - 1];
        const data = Object.assign({}, options.data);
        if (arguments.length === 3) {
            // If given two numbers then pick a random one between the two
            count = (0, utils_1.RandomInt)(args[0], args[1]);
        }
        else if (arguments.length === 2) {
            count = args[0];
        }
        else {
            throw new Error('The repeat helper requires a numeric param');
        }
        for (let i = 0; i < count; i++) {
            // You can access these in your template using @index, @total, @first, @last
            data.index = i;
            data.total = count;
            data.first = i === 0;
            data.last = i === count - 1;
            // By using 'this' as the context the repeat block will inherit the current scope
            content = content + options.fn(this, { data });
            if (options.hash.comma !== false) {
                // Trim any whitespace left by handlebars and add a comma if it doesn't already exist,
                // also trim any trailing commas that might be at the end of the loop
                content = content.trimRight();
                if (i < count - 1 && content.charAt(content.length - 1) !== ',') {
                    content += ',';
                }
                else if (i === count - 1 &&
                    content.charAt(content.length - 1) === ',') {
                    content = content.slice(0, -1);
                }
                content += os_1.EOL;
            }
        }
        return content;
    },
    // return one random item
    oneOf: function (itemList) {
        return itemList[(0, utils_1.RandomInt)(0, itemList.length - 1)];
    },
    // return some random item as an array (to be used in triple braces) or as a string
    someOf: function (itemList, min, max, asArray = false) {
        const randomItems = itemList
            .sort(() => 0.5 - Math.random())
            .slice(0, (0, utils_1.RandomInt)(min, max));
        if (asArray === true) {
            return `["${randomItems.join('","')}"]`;
        }
        return randomItems;
    },
    // create an array
    array: function (...args) {
        // remove last item (handlebars options argument)
        return args.slice(0, args.length - 1);
    },
    // switch cases
    switch: function (value, options) {
        options.data.found = false;
        options.data.switchValue = (0, utils_1.fromSafeString)(value);
        return options.fn(options);
    },
    // case helper for switch
    case: function (...args) {
        let value = '';
        let options;
        if (args.length >= 2) {
            value = args[0];
            options = args[args.length - 1];
        }
        if (value === options.data.switchValue && !options.data.found) {
            // check switch value to simulate break
            options.data.found = true;
            return options.fn(options);
        }
    },
    // default helper for switch
    default: function (options) {
        // if there is still a switch value show default content
        if (!options.data.found) {
            delete options.data.switchValue;
            return options.fn(options);
        }
        return '';
    },
    // provide current time with format
    now: function (format) {
        return (0, date_fns_1.format)(new Date(), typeof format === 'string' ? format : "yyyy-MM-dd'T'HH:mm:ss.SSSxxx", {
            useAdditionalWeekYearTokens: true,
            useAdditionalDayOfYearTokens: true
        });
    },
    // converts the input to a base64 string
    base64: function (...args) {
        const hbsOptions = args[args.length - 1];
        let content;
        if (args.length === 1) {
            content = hbsOptions.fn(hbsOptions);
        }
        else {
            content = args[0];
        }
        // convert content toString in case we pass a SafeString from another helper
        return new handlebars_1.SafeString((0, utils_1.ToBase64)(content.toString()));
    },
    // convert base64 to a string
    base64Decode: function (...args) {
        const hbsOptions = args[args.length - 1];
        let content;
        if (args.length === 1) {
            content = hbsOptions.fn(hbsOptions);
        }
        else {
            content = args[0];
        }
        // convert content toString in case we pass a SafeString from another helper
        return new handlebars_1.SafeString((0, utils_1.FromBase64)(content.toString()));
    },
    // adds a newline to the output
    newline: function () {
        return '\n';
    },
    // returns a Mongodb ObjectId
    objectId: function () {
        return faker_1.faker.database.mongodbObjectId();
    },
    // concat multiple string and/or variables (like @index)
    concat: function (...args) {
        // remove handlebars options
        const toConcat = args.slice(0, args.length - 1);
        return toConcat.join('');
    },
    // Shift a date and time by a specified ammount.
    dateTimeShift: function (options) {
        let date;
        let format;
        if (typeof options === 'object' && options.hash) {
            date = (0, utils_1.fromSafeString)(options.hash['date']);
            format = (0, utils_1.fromSafeString)(options.hash['format']);
        }
        // If no date is specified, default to now. If a string is specified, then parse it to a date.
        const dateToShift = date === undefined
            ? new Date()
            : typeof date === 'string'
                ? new Date(date)
                : date;
        if (typeof options === 'object' && options !== null && options.hash) {
            const days = (0, utils_1.numberFromSafeString)(options.hash['days']);
            const months = (0, utils_1.numberFromSafeString)(options.hash['months']);
            const years = (0, utils_1.numberFromSafeString)(options.hash['years']);
            const hours = (0, utils_1.numberFromSafeString)(options.hash['hours']);
            const minutes = (0, utils_1.numberFromSafeString)(options.hash['minutes']);
            const seconds = (0, utils_1.numberFromSafeString)(options.hash['seconds']);
            if (!isNaN(days)) {
                dateToShift.setDate(dateToShift.getDate() + days);
            }
            if (!isNaN(months)) {
                dateToShift.setMonth(dateToShift.getMonth() + months);
            }
            if (!isNaN(years)) {
                dateToShift.setFullYear(dateToShift.getFullYear() + years);
            }
            if (!isNaN(hours)) {
                dateToShift.setHours(dateToShift.getHours() + hours);
            }
            if (!isNaN(minutes)) {
                dateToShift.setMinutes(dateToShift.getMinutes() + minutes);
            }
            if (!isNaN(seconds)) {
                dateToShift.setSeconds(dateToShift.getSeconds() + seconds);
            }
        }
        return (0, date_fns_1.format)(dateToShift, typeof format === 'string' ? format : "yyyy-MM-dd'T'HH:mm:ss.SSSxxx", {
            useAdditionalWeekYearTokens: true,
            useAdditionalDayOfYearTokens: true
        });
    },
    // Get's the index of a search string within another string.
    indexOf: function (data, search, position) {
        data =
            typeof data === 'object' && !(data instanceof handlebars_1.SafeString)
                ? ''
                : data.toString();
        search =
            (typeof search === 'object' || typeof search === 'undefined') &&
                !(search instanceof handlebars_1.SafeString)
                ? ''
                : search.toString();
        position =
            (typeof position === 'object' || typeof position === 'undefined') &&
                !(position instanceof handlebars_1.SafeString)
                ? undefined
                : Number(position.toString());
        if (typeof position === 'number') {
            return data.indexOf(search, position);
        }
        else {
            return data.indexOf(search);
        }
    },
    // Returns if the provided search string is contained in the data string.
    includes: function (data, search) {
        data =
            (typeof data === 'object' || typeof data == 'undefined') &&
                !(data instanceof handlebars_1.SafeString)
                ? ''
                : data.toString();
        search =
            (typeof search === 'object' || typeof search == 'undefined') &&
                !(search instanceof handlebars_1.SafeString)
                ? ''
                : search.toString();
        return data.includes(search);
    },
    // Returns the substring of a string based on the passed in starting index and length.
    substr: function (data, from, length) {
        data =
            typeof data === 'object' && !(data instanceof handlebars_1.SafeString)
                ? ''
                : data.toString();
        const fromValue = (typeof from === 'object' || typeof from == 'undefined') &&
            !(from instanceof handlebars_1.SafeString)
            ? 0
            : Number(from.toString());
        const lengthValue = (typeof length === 'object' || typeof length == 'undefined') &&
            !(length instanceof handlebars_1.SafeString)
            ? undefined
            : Number(length.toString());
        if (typeof lengthValue !== 'undefined') {
            return data.substr(fromValue, lengthValue);
        }
        else {
            return data.substr(fromValue);
        }
    },
    // Split a string, default separator is " "
    split: function (...args) {
        const parameters = args.slice(0, -1);
        if (parameters.length === 0) {
            return '';
        }
        // make it compatible with SafeString (from queryParam, etc)
        const data = (0, utils_1.fromSafeString)(parameters[0]);
        let separator;
        if (parameters.length >= 2) {
            separator = parameters[1];
        }
        if (!separator || typeof separator !== 'string') {
            separator = ' ';
        }
        if (!data || typeof data !== 'string') {
            return '';
        }
        return data.split(separator);
    },
    lowercase: function (...args) {
        const parameters = args.slice(0, -1);
        if (parameters.length === 0) {
            return '';
        }
        // make it compatible with SafeString (from queryParam, etc)
        const text = (0, utils_1.fromSafeString)(parameters[0]);
        return text.toLowerCase();
    },
    uppercase: function (...args) {
        const parameters = args.slice(0, -1);
        if (parameters.length === 0) {
            return '';
        }
        // make it compatible with SafeString (from queryParam, etc)
        const text = (0, utils_1.fromSafeString)(parameters[0]);
        return text.toUpperCase();
    },
    // parse a string and returns corresponding int
    parseInt: function (...args) {
        const parameters = args.slice(0, -1);
        if (parameters.length === 0) {
            return '';
        }
        // make it compatible with SafeString (from queryParam, etc)
        const text = (0, utils_1.fromSafeString)(parameters[0]);
        const result = parseInt(text, 10);
        if (isNaN(result)) {
            return '';
        }
        else {
            return result;
        }
    },
    // Joins Array Values as String with separator
    join: function (arr, sep) {
        if (!arr || !(arr instanceof Array)) {
            return arr;
        }
        return arr.join(typeof sep !== 'string' ? ', ' : sep);
    },
    slice: function (arr, sliceFrom, sliceTo) {
        if (!(arr instanceof Array)) {
            return '';
        }
        return typeof sliceTo === 'number'
            ? arr.slice(sliceFrom, sliceTo)
            : arr.slice(sliceFrom);
    },
    // Returns array length or string length
    len: function (arr) {
        return typeof arr !== 'string' && !Array.isArray(arr) ? 0 : arr.length;
    },
    eq: function (num1, num2) {
        const number1 = Number(num1);
        const number2 = Number(num2);
        if (Number.isNaN(number1) || Number.isNaN(number2)) {
            return false;
        }
        return number1 === number2;
    },
    gt: function (num1, num2) {
        const number1 = Number(num1);
        const number2 = Number(num2);
        if (Number.isNaN(number1) || Number.isNaN(number2)) {
            return false;
        }
        return number1 > number2;
    },
    gte: function (num1, num2) {
        const number1 = Number(num1);
        const number2 = Number(num2);
        if (Number.isNaN(number1) || Number.isNaN(number2)) {
            return false;
        }
        return number1 >= number2;
    },
    lt: function (num1, num2) {
        const number1 = Number(num1);
        const number2 = Number(num2);
        if (Number.isNaN(number1) || Number.isNaN(number2)) {
            return false;
        }
        return number1 < number2;
    },
    lte: function (num1, num2) {
        const number1 = Number(num1);
        const number2 = Number(num2);
        if (Number.isNaN(number1) || Number.isNaN(number2)) {
            return false;
        }
        return number1 <= number2;
    },
    // set a variable to be used in the template
    setVar: function (...args) {
        // return if not all parameters have been provided
        if (arguments.length < 3) {
            return;
        }
        const options = args[args.length - 1];
        const name = args[0];
        const value = args[1];
        if (!options.data) {
            options.data = {};
        }
        options.data[name] = value;
    },
    int: function (...args) {
        const options = {
            precision: 1
        };
        if (args.length >= 2 && typeof args[0] === 'number') {
            options.min = args[0];
        }
        if (args.length >= 3 && typeof args[1] === 'number') {
            options.max = args[1];
        }
        return faker_1.faker.datatype.number(options);
    },
    float: function (...args) {
        const options = {
            precision: Math.pow(10, -10)
        };
        if (args.length >= 2 && typeof args[0] === 'number') {
            options.min = args[0];
        }
        if (args.length >= 3 && typeof args[1] === 'number') {
            options.max = args[1];
        }
        return faker_1.faker.datatype.number(options);
    },
    date: function (...args) {
        let format;
        const from = (0, utils_1.fromSafeString)(args[0]);
        const to = (0, utils_1.fromSafeString)(args[1]);
        if (args.length >= 3 &&
            typeof from === 'string' &&
            typeof to === 'string') {
            const randomDate = faker_1.faker.date.between(from, to);
            if (args.length === 4 && typeof args[2] === 'string') {
                format = args[2];
                return (0, date_fns_1.format)(randomDate, format, {
                    useAdditionalWeekYearTokens: true,
                    useAdditionalDayOfYearTokens: true
                });
            }
            return randomDate.toString();
        }
        return '';
    },
    // Format a date and time to a specific format
    dateFormat: function (...args) {
        const date = (0, utils_1.fromSafeString)(args[0]);
        const format = (0, utils_1.fromSafeString)(args[1]);
        if (args.length >= 2 &&
            typeof date === 'string' &&
            typeof format === 'string') {
            return (0, date_fns_1.format)(new Date(date), format, {
                useAdditionalWeekYearTokens: true,
                useAdditionalDayOfYearTokens: true
            });
        }
        return '';
    },
    time: function (...args) {
        let from, to, format;
        if (args.length >= 3 &&
            typeof args[0] === 'string' &&
            typeof args[1] === 'string') {
            from = `1970-01-01T${args[0]}`;
            to = `1970-01-01T${args[1]}`;
            if (args.length === 4 && typeof args[2] === 'string') {
                format = args[2];
            }
            return (0, date_fns_1.format)(faker_1.faker.date.between(from, to), format || 'HH:mm', {
                useAdditionalWeekYearTokens: true,
                useAdditionalDayOfYearTokens: true
            });
        }
        return '';
    },
    boolean: function () {
        return faker_1.faker.datatype.boolean();
    },
    title: function () {
        return faker_1.faker.name.prefix();
    },
    firstName: function () {
        return faker_1.faker.name.firstName();
    },
    lastName: function () {
        return faker_1.faker.name.lastName();
    },
    company: function () {
        return faker_1.faker.company.companyName();
    },
    domain: function () {
        return faker_1.faker.internet.domainName();
    },
    tld: function () {
        return faker_1.faker.internet.domainSuffix();
    },
    email: function () {
        return faker_1.faker.internet.email();
    },
    street: function () {
        return faker_1.faker.address.streetAddress();
    },
    city: function () {
        return faker_1.faker.address.city();
    },
    country: function () {
        return faker_1.faker.address.country();
    },
    countryCode: function () {
        return faker_1.faker.address.countryCode();
    },
    zipcode: function () {
        return faker_1.faker.address.zipCode();
    },
    postcode: function () {
        return faker_1.faker.address.zipCode();
    },
    lat: function () {
        return faker_1.faker.address.latitude();
    },
    long: function () {
        return faker_1.faker.address.longitude();
    },
    phone: function () {
        return faker_1.faker.phone.phoneNumber();
    },
    color: function () {
        return faker_1.faker.commerce.color();
    },
    hexColor: function () {
        return Math.floor(faker_1.faker.datatype.number({ min: 0, max: 1, precision: Math.pow(10, -16) }) *
            16777215).toString(16);
    },
    guid: function () {
        return faker_1.faker.datatype.uuid();
    },
    ipv4: function () {
        return faker_1.faker.internet.ip();
    },
    ipv6: function () {
        return faker_1.faker.internet.ipv6();
    },
    lorem: function (...args) {
        let count;
        if (args.length >= 2 && typeof args[0] === 'number') {
            count = args[0];
        }
        return faker_1.faker.lorem.sentence(count);
    },
    // Handlebars hook when a helper is missing
    helperMissing: function () {
        return '';
    },
    // Maths helpers
    add: function (...args) {
        // Check if there are parameters
        if (args.length === 1) {
            return '';
        }
        return args.reduce((sum, item, index) => {
            if (!isNaN(Number((0, utils_1.fromSafeString)(item))) && index !== args.length - 1) {
                return Number(sum) + Number(item);
            }
            else {
                return Number(sum);
            }
        });
    },
    subtract: function (...args) {
        // Check if there are parameters
        if (args.length === 1) {
            return '';
        }
        return args.reduce((sum, item, index) => {
            if (!isNaN(Number((0, utils_1.fromSafeString)(item))) && index !== args.length - 1) {
                return Number(sum) - Number(item);
            }
            else {
                return Number(sum);
            }
        });
    },
    multiply: function (...args) {
        // Check if there are parameters
        if (args.length === 1) {
            return '';
        }
        return args.reduce((sum, item, index) => {
            if (!isNaN(Number((0, utils_1.fromSafeString)(item))) && index !== args.length - 1) {
                return Number(sum) * Number(item);
            }
            else {
                return Number(sum);
            }
        });
    },
    divide: function (...args) {
        // Check if there are parameters
        if (args.length === 1) {
            return '';
        }
        return args.reduce((sum, item, index) => {
            if (!isNaN(Number((0, utils_1.fromSafeString)(item))) &&
                index !== args.length - 1 &&
                Number(item) !== 0) {
                return Number(sum) / Number(item);
            }
            else {
                return Number(sum);
            }
        });
    },
    modulo: function (...args) {
        const parameters = args.slice(0, -1);
        // Check if there are parameters or if attempting to compute modulo 0
        if (parameters.length <= 1 || Number(parameters[1]) === 0) {
            return '';
        }
        return Number(parameters[0]) % Number(parameters[1]);
    },
    ceil: function (...args) {
        const parameters = args.slice(0, -1);
        // Check if there are parameters
        if (parameters.length === 0) {
            return '';
        }
        return Math.ceil(Number(parameters[0]));
    },
    floor: function (...args) {
        const parameters = args.slice(0, -1);
        // Check if there are parameters
        if (parameters.length === 0) {
            return '';
        }
        return Math.floor(Number(parameters[0]));
    },
    round: function (...args) {
        const parameters = args.slice(0, -1);
        // Check if there are parameters
        if (parameters.length === 0) {
            return '';
        }
        return Math.round(Number(parameters[0]));
    },
    toFixed: function (number, digits) {
        if (Number.isNaN(Number(number))) {
            number = 0;
        }
        if (Number.isNaN(Number(digits))) {
            digits = 0;
        }
        return Number(number).toFixed(digits);
    },
    // Returns Objects as formatted JSON String
    stringify: function (data, options) {
        if (!options) {
            return;
        }
        if (data && typeof data === 'object') {
            return JSON.stringify(data, null, 2);
        }
        else {
            return data;
        }
    }
};
//# sourceMappingURL=helpers.js.map