"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenAPIConverter = void 0;
const swagger_parser_1 = __importDefault(require("@apidevtools/swagger-parser"));
const commons_1 = require("@mockoon/commons");
const utils_1 = require("./utils");
/**
 * Convert to and from Swagger/OpenAPI formats
 *
 * OpenAPI specifications: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md
 * Swagger specifications: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md
 *
 */
class OpenAPIConverter {
    constructor() { }
    /**
     * Import Swagger or OpenAPI format
     *
     * @param filePath
     */
    async convertFromOpenAPI(filePath, port) {
        try {
            // .bind() due to https://github.com/APIDevTools/json-schema-ref-parser/issues/139#issuecomment-940500698
            const parsedAPI = await swagger_parser_1.default.dereference.bind(swagger_parser_1.default)(filePath, {
                dereference: { circular: 'ignore' }
            });
            if (this.isSwagger(parsedAPI)) {
                return this.convertFromSwagger(parsedAPI, port);
            }
            else if (this.isOpenAPIV3(parsedAPI)) {
                return this.convertFromOpenAPIV3(parsedAPI, port);
            }
            return null;
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * Convert environment to OpenAPI JSON object
     *
     * @param environment
     */
    async convertToOpenAPIV3(environment) {
        const routes = (0, utils_1.routesFromFolder)(environment.rootChildren, environment.folders, environment.routes);
        const openAPIEnvironment = {
            openapi: '3.0.0',
            info: { title: environment.name, version: '1.0.0' },
            servers: [
                {
                    url: `${environment.tlsOptions.enabled ? 'https' : 'http'}://localhost:${environment.port}/${environment.endpointPrefix}`
                }
            ],
            paths: routes.reduce((paths, route) => {
                const pathParameters = route.endpoint.match(/:[a-zA-Z0-9_]+/g);
                let endpoint = '/' + route.endpoint;
                if (pathParameters && pathParameters.length > 0) {
                    endpoint = '/' + route.endpoint.replace(/:([a-zA-Z0-9_]+)/g, '{$1}');
                }
                if (!paths[endpoint]) {
                    paths[endpoint] = {};
                }
                paths[endpoint][route.method] = {
                    description: route.documentation,
                    responses: route.responses.reduce((responses, routeResponse) => {
                        const responseContentType = (0, commons_1.GetRouteResponseContentType)(environment, routeResponse);
                        responses[routeResponse.statusCode.toString()] = {
                            description: routeResponse.label,
                            content: responseContentType
                                ? { [responseContentType]: {} }
                                : {},
                            headers: [
                                ...environment.headers,
                                ...routeResponse.headers
                            ].reduce((headers, header) => {
                                if (header.key.toLowerCase() !== 'content-type') {
                                    headers[header.key] = {
                                        schema: { type: 'string' },
                                        example: header.value
                                    };
                                }
                                return headers;
                            }, {})
                        };
                        return responses;
                    }, {})
                };
                if (pathParameters && pathParameters.length > 0) {
                    paths[endpoint][route.method].parameters = pathParameters.reduce((parameters, parameter) => {
                        parameters.push({
                            name: parameter.slice(1, parameter.length),
                            in: 'path',
                            schema: { type: 'string' },
                            required: true
                        });
                        return parameters;
                    }, []);
                }
                return paths;
            }, {})
        };
        try {
            await swagger_parser_1.default.validate(openAPIEnvironment);
            return JSON.stringify(openAPIEnvironment);
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * Convert Swagger 2.0 format
     *
     * @param parsedAPI
     */
    convertFromSwagger(parsedAPI, port) {
        const newEnvironment = (0, commons_1.BuildEnvironment)({
            hasDefaultHeader: false,
            hasDefaultRoute: false,
            port
        });
        // parse the port
        newEnvironment.port =
            (parsedAPI.host && parseInt(parsedAPI.host.split(':')[1], 10)) ||
                newEnvironment.port;
        if (parsedAPI.basePath) {
            newEnvironment.endpointPrefix = (0, commons_1.RemoveLeadingSlash)(parsedAPI.basePath);
        }
        newEnvironment.name = parsedAPI.info.title || 'Swagger import';
        newEnvironment.routes = this.createRoutes(parsedAPI, 'SWAGGER');
        newEnvironment.rootChildren = newEnvironment.routes.map((route) => ({
            type: 'route',
            uuid: route.uuid
        }));
        return newEnvironment;
    }
    /**
     * Convert OpenAPI 3.0 format
     *
     * @param parsedAPI
     */
    convertFromOpenAPIV3(parsedAPI, port) {
        var _a;
        const newEnvironment = (0, commons_1.BuildEnvironment)({
            hasDefaultHeader: false,
            hasDefaultRoute: false,
            port
        });
        const server = parsedAPI.servers;
        if ((_a = server === null || server === void 0 ? void 0 : server[0]) === null || _a === void 0 ? void 0 : _a.url) {
            newEnvironment.endpointPrefix = (0, commons_1.RemoveLeadingSlash)(new URL(this.v3ParametersReplace(server[0].url, server[0].variables))
                .pathname);
        }
        newEnvironment.name = parsedAPI.info.title || 'OpenAPI import';
        newEnvironment.routes = this.createRoutes(parsedAPI, 'OPENAPI_V3');
        newEnvironment.rootChildren = newEnvironment.routes.map((route) => ({
            type: 'route',
            uuid: route.uuid
        }));
        return newEnvironment;
    }
    createRoutes(parsedAPI, version) {
        const routes = [];
        Object.keys(parsedAPI.paths).forEach((routePath) => {
            Object.keys(parsedAPI.paths[routePath]).forEach((routeMethod) => {
                const parsedRoute = parsedAPI.paths[routePath][routeMethod];
                if (routeMethod in commons_1.Methods) {
                    const routeResponses = [];
                    Object.keys(parsedRoute.responses).forEach((responseStatus) => {
                        var _a, _b;
                        const statusCode = parseInt(responseStatus, 10);
                        // filter unsupported status codes (i.e. ranges containing "X", 4XX, 5XX, etc)
                        // consider 'default' as 200
                        if ((statusCode >= 100 && statusCode <= 999) ||
                            responseStatus === 'default') {
                            const routeResponse = parsedRoute.responses[responseStatus];
                            let contentTypeHeaders = [];
                            let schema;
                            let examples;
                            if (version === 'SWAGGER') {
                                contentTypeHeaders =
                                    parsedRoute.produces ||
                                        parsedRoute.consumes ||
                                        parsedAPI.produces ||
                                        parsedAPI.consumes ||
                                        [];
                            }
                            else if (version === 'OPENAPI_V3' && routeResponse.content) {
                                contentTypeHeaders = Object.keys(routeResponse.content);
                            }
                            // extract schema
                            const contentTypeHeader = contentTypeHeaders.find((header) => header.includes('application/json'));
                            if (contentTypeHeader) {
                                if (version === 'SWAGGER') {
                                    schema = routeResponse.schema;
                                    examples = routeResponse.examples;
                                }
                                else if (version === 'OPENAPI_V3') {
                                    schema = (_a = routeResponse.content) === null || _a === void 0 ? void 0 : _a[contentTypeHeader].schema;
                                    examples =
                                        (_b = routeResponse.content) === null || _b === void 0 ? void 0 : _b[contentTypeHeader].examples;
                                }
                            }
                            const headers = this.buildResponseHeaders(contentTypeHeaders, routeResponse.headers);
                            routeResponses.push(this.buildResponse(schema ? this.generateSchema(schema) : undefined, routeResponse.description || '', responseStatus === 'default' ? 200 : statusCode, headers));
                            // add response based on examples
                            if (examples) {
                                const routeResponseExamples = this.parseOpenAPIExamples(examples, version).map((example) => this.buildResponse(example.body, example.label, responseStatus === 'default' ? 200 : statusCode, headers));
                                routeResponses.push(...routeResponseExamples);
                            }
                        }
                    });
                    // check if has at least one response
                    if (!routeResponses.length) {
                        routeResponses.push(Object.assign(Object.assign({}, (0, commons_1.BuildRouteResponse)()), { headers: [(0, commons_1.BuildHeader)('Content-Type', 'application/json')], body: '' }));
                    }
                    // mark the first route response as default
                    routeResponses[0].default = true;
                    const newRoute = Object.assign(Object.assign({}, (0, commons_1.BuildRoute)(commons_1.RouteType.HTTP, false)), { documentation: parsedRoute.summary || parsedRoute.description || '', method: routeMethod, endpoint: (0, commons_1.RemoveLeadingSlash)(this.v2ParametersReplace(routePath)), responses: routeResponses });
                    routes.push(newRoute);
                }
            });
        });
        return routes;
    }
    /**
     * Build route response headers from 'content' (v3) or 'produces' (v2), and 'headers' objects
     *
     * @param contentTypes
     * @param responseHeaders
     */
    buildResponseHeaders(contentTypes, responseHeaders) {
        const routeContentTypeHeader = (0, commons_1.BuildHeader)('Content-Type', 'application/json');
        if (contentTypes &&
            contentTypes.length &&
            !contentTypes.includes('application/json')) {
            routeContentTypeHeader.value = contentTypes[0];
        }
        if (responseHeaders) {
            return [
                routeContentTypeHeader,
                ...Object.keys(responseHeaders).map((header) => (0, commons_1.BuildHeader)(header, ''))
            ];
        }
        return [routeContentTypeHeader];
    }
    /**
     * Build route response from label, status code, headers and unformatted body.
     * @param body
     * @param label
     * @param statusCode
     * @param headers
     * @private
     */
    buildResponse(body, label, statusCode, headers) {
        return Object.assign(Object.assign({}, (0, commons_1.BuildRouteResponse)()), { body: body !== undefined
                ? this.convertJSONSchemaPrimitives(JSON.stringify(body, null, commons_1.INDENT_SIZE))
                : '', label,
            statusCode,
            headers });
    }
    /**
     * Replace parameters in `str`
     *
     * @param str
     */
    v2ParametersReplace(str) {
        return str.replace(/{(\w+)}/gi, (searchValue, replaceValue) => ':' + replaceValue);
    }
    /**
     * Replace parameters in `str` with server variables
     *
     * @param str
     * @param parameters
     * @returns
     */
    v3ParametersReplace(str, parameters) {
        return str.replace(/{(\w+)}/gi, (searchValue, replaceValue) => parameters ? parameters[replaceValue].default : '');
    }
    /**
     * Swagger specification type guard
     *
     * @param parsedAPI
     */
    isSwagger(parsedAPI) {
        return parsedAPI.swagger !== undefined;
    }
    /**
     * OpenAPI v3 specification type guard
     *
     * @param parsedAPI
     */
    isOpenAPIV3(parsedAPI) {
        return (parsedAPI.openapi !== undefined && parsedAPI.openapi.startsWith('3.'));
    }
    /**
     * Generate a JSON object from a schema
     *
     */
    generateSchema(schema) {
        const typeFactories = {
            integer: () => "{{faker 'datatype.number'}}",
            number: () => "{{faker 'datatype.number'}}",
            number_float: () => "{{faker 'datatype.float'}}",
            number_double: () => "{{faker 'datatype.float'}}",
            string: () => '',
            string_date: () => "{{date '2019' (now) 'yyyy-MM-dd'}}",
            'string_date-time': () => "{{faker 'date.recent' 365}}",
            string_email: () => "{{faker 'internet.email'}}",
            string_uuid: () => "{{faker 'datatype.uuid'}}",
            boolean: () => "{{faker 'datatype.boolean'}}",
            array: (arraySchema) => {
                const newObject = this.generateSchema(arraySchema.items);
                return arraySchema.collectionFormat === 'csv' ? newObject : [newObject];
            },
            object: (objectSchema) => {
                const newObject = {};
                const { properties } = objectSchema;
                if (properties) {
                    Object.keys(properties).forEach((propertyName) => {
                        newObject[propertyName] = this.generateSchema(properties[propertyName]);
                    });
                }
                return newObject;
            }
        };
        if (schema instanceof Object) {
            let type = Array.isArray(schema.type) && schema.type.length >= 1
                ? schema.type[0]
                : schema.type;
            // use enum property if present
            if (schema.enum) {
                return `{{oneOf (array '${schema.enum.join("' '")}')}}`;
            }
            // return example if any
            if (schema.example) {
                return schema.example;
            }
            // return default value if any
            if (schema.default) {
                return schema.default;
            }
            let schemaToBuild = schema;
            // check if we have an array of schemas, and take first item
            ['allOf', 'oneOf', 'anyOf'].forEach((propertyName) => {
                if (schema.hasOwnProperty(propertyName) &&
                    schema[propertyName].length > 0) {
                    type = schema[propertyName][0].type;
                    schemaToBuild = schema[propertyName][0];
                }
            });
            // sometimes we have no type but only 'properties' (=object)
            if (!type &&
                schemaToBuild.properties &&
                schemaToBuild.properties instanceof Object) {
                type = 'object';
            }
            const typeFactory = typeFactories[`${type}_${schemaToBuild.format}`] || typeFactories[type];
            if (typeFactory) {
                return typeFactory(schemaToBuild);
            }
            return '';
        }
    }
    /**
     * After generating example bodies, remove the quotes around some
     * primitive helpers
     *
     * @param jsonSchema
     */
    convertJSONSchemaPrimitives(jsonSchema) {
        return jsonSchema.replace(/\"({{faker 'datatype\.(number|boolean|float)'}})\"/g, '$1');
    }
    /**
     * Extract bodies and labels from OpenAPI examples
     * @param examples
     * @param version
     * @private
     */
    parseOpenAPIExamples(examples, version) {
        const responses = [];
        Object.keys(examples).forEach((exampleName) => {
            const example = examples[exampleName];
            const exampleBody = version === 'SWAGGER' ? example : example.value;
            const exampleResponse = {
                body: exampleBody,
                label: exampleName
            };
            responses.push(exampleResponse);
        });
        return responses;
    }
}
exports.OpenAPIConverter = OpenAPIConverter;
//# sourceMappingURL=openapi-converter.js.map