"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dedupSlashes = exports.routesFromFolder = exports.convertPathToArray = exports.stringIncludesArrayItems = exports.resolvePathFromEnvironment = exports.numberFromSafeString = exports.fromSafeString = exports.FromBase64 = exports.ToBase64 = exports.CreateTransaction = exports.DecompressBody = exports.RandomInt = exports.IsEmpty = void 0;
const handlebars_1 = require("handlebars");
const path_1 = require("path");
const url_1 = require("url");
const zlib_1 = require("zlib");
/**
 * Transform http headers objects to Mockoon's Header key value object
 *
 * @param object
 */
const TransformHeaders = (headers) => Object.keys(headers).reduce((newHeaders, key) => {
    const headerValue = headers[key];
    let value = '';
    if (headerValue !== undefined) {
        if (Array.isArray(headerValue)) {
            value = headerValue.join(',');
        }
        else {
            value = headerValue.toString();
        }
    }
    newHeaders.push({ key, value });
    return newHeaders;
}, []);
/**
 * Sort by ascending order
 *
 * @param a
 * @param b
 */
const AscSort = (a, b) => {
    if (a.key < b.key) {
        return -1;
    }
    else {
        return 1;
    }
};
/**
 * Check if an Object or Array is empty
 *
 * @param obj
 */
const IsEmpty = (obj) => [Object, Array].includes((obj || {}).constructor) &&
    !Object.entries(obj || {}).length;
exports.IsEmpty = IsEmpty;
/**
 * Return a random integer
 *
 * @param a
 * @param b
 */
const RandomInt = (a = 1, b = 0) => {
    const lower = Math.ceil(Math.min(a, b));
    const upper = Math.floor(Math.max(a, b));
    return Math.floor(lower + Math.random() * (upper - lower + 1));
};
exports.RandomInt = RandomInt;
/**
 * Decompress body based on content-encoding
 *
 * @param response
 */
const DecompressBody = (response) => {
    if (!response.body) {
        return response.body;
    }
    const contentEncoding = response.getHeader('content-encoding');
    let body = response.body;
    switch (contentEncoding) {
        case 'gzip':
            body = (0, zlib_1.unzipSync)(body);
            break;
        case 'br':
            body = (0, zlib_1.brotliDecompressSync)(body);
            break;
        case 'deflate':
            body = (0, zlib_1.inflateSync)(body);
            break;
        default:
            break;
    }
    return body.toString('utf-8');
};
exports.DecompressBody = DecompressBody;
/**
 * Create a Transaction object from express req/res.
 * To be used after the response closes
 *
 * @param request
 * @param response
 */
function CreateTransaction(request, response) {
    const requestUrl = new url_1.URL(request.originalUrl, 'http://localhost/');
    let queryString = requestUrl.search.slice(1);
    try {
        queryString = decodeURI(queryString);
    }
    catch (err) { }
    return {
        request: {
            method: request.method.toLowerCase(),
            urlPath: requestUrl.pathname,
            route: request.route ? request.route.path : null,
            params: request.params
                ? Object.keys(request.params).map((paramName) => ({
                    name: paramName,
                    value: request.params[paramName]
                }))
                : [],
            query: requestUrl ? queryString : null,
            queryParams: request.query,
            body: request.stringBody,
            headers: TransformHeaders(request.headers).sort(AscSort)
        },
        response: {
            statusCode: response.statusCode,
            statusMessage: response.statusMessage,
            headers: TransformHeaders(response.getHeaders()).sort(AscSort),
            body: (0, exports.DecompressBody)(response)
        },
        routeResponseUUID: response.routeResponseUUID,
        routeUUID: response.routeUUID,
        proxied: request.proxied || false
    };
}
exports.CreateTransaction = CreateTransaction;
/**
 * Convert a string to base64
 *
 * @param text
 */
const ToBase64 = (text) => Buffer.from(text, 'utf-8').toString('base64');
exports.ToBase64 = ToBase64;
/**
 * Convert base64 to a string
 *
 * @param base64
 */
const FromBase64 = (base64) => Buffer.from(base64, 'base64').toString('utf-8');
exports.FromBase64 = FromBase64;
/**
 * Convert a SafeString to a string if needed.
 *
 * @param text
 * @returns
 */
const fromSafeString = (text) => text instanceof handlebars_1.SafeString ? text.toString() : text;
exports.fromSafeString = fromSafeString;
/**
 * Parse a number from a SafeString if needed.
 *
 * @param text
 * @returns
 */
const numberFromSafeString = (text) => {
    const parsedText = text instanceof handlebars_1.SafeString ? text.toString() : text;
    return parseInt(parsedText, 10);
};
exports.numberFromSafeString = numberFromSafeString;
/**
 * Resolve a file path relatively to the current environment folder if provided
 */
const resolvePathFromEnvironment = (filePath, environmentDirectory) => {
    if (environmentDirectory && !(0, path_1.isAbsolute)(filePath)) {
        return (0, path_1.resolve)(environmentDirectory, filePath);
    }
    return filePath;
};
exports.resolvePathFromEnvironment = resolvePathFromEnvironment;
/**
 * Check that at least one item of the array is included in the provided string
 *
 * @param array
 * @param str
 * @returns
 */
const stringIncludesArrayItems = (array, str) => array.some((item) => str.includes(item));
exports.stringIncludesArrayItems = stringIncludesArrayItems;
/**
 * Convert an object path (for the object-path lib) containing escaped dots '\.'
 * to an array of strings to allow fetching properties containing dots.
 *
 * Example:
 * 'get.a.property\.with\.dots => ['get', 'a', 'property.with.dots']
 *
 * To query an object like this:
 *
 * ```
 * {
 *   get: {
 *     a: {
 *       'propery.with.dots': "value"
 *     }
 *   }
 * }
 * ```
 * @param str
 */
const convertPathToArray = (str) => {
    if (str.includes('\\.')) {
        return str
            .replace(/\\\./g, '%#%')
            .split('.')
            .map((s) => s.replace(/%#%/g, '.'));
    }
    return str;
};
exports.convertPathToArray = convertPathToArray;
/**
 * List routes in the order they appear in a folder children array (can be called recursively)
 *
 * @param folderChildren
 * @param allFolders
 * @param allRoutes
 * @returns
 */
const routesFromFolder = (folderChildren, allFolders, allRoutes) => {
    const routesList = [];
    folderChildren.forEach((folderChild) => {
        if (folderChild.type === 'route') {
            const foundRoute = allRoutes.find((route) => route.uuid === folderChild.uuid);
            if (foundRoute) {
                routesList.push(foundRoute);
            }
        }
        else {
            const subFolder = allFolders.find((folder) => folder.uuid === folderChild.uuid);
            if (subFolder) {
                routesList.push(...(0, exports.routesFromFolder)(subFolder.children, allFolders, allRoutes));
            }
        }
    });
    return routesList;
};
exports.routesFromFolder = routesFromFolder;
/**
 * Remove duplicate slashes from a string
 *
 * @param str
 * @returns
 */
const dedupSlashes = (str) => str.replace(/\/{2,}/g, '/');
exports.dedupSlashes = dedupSlashes;
//# sourceMappingURL=utils.js.map