import { BINARY_BODY, BodyTypes, CommonsTexts, CORSHeaders, GetContentType, GetRouteResponseContentType, IsValidURL, MimeTypesWithTemplating, RouteType, ServerErrorCodes } from '@mockoon/commons';
import appendField from 'append-field';
import busboy from 'busboy';
import cookieParser from 'cookie-parser';
import { EventEmitter } from 'events';
import express from 'express';
import { createReadStream, readFile, readFileSync, statSync } from 'fs';
import { createServer as httpCreateServer } from 'http';
import { createProxyMiddleware } from 'http-proxy-middleware';
import { createServer as httpsCreateServer } from 'https';
import killable from 'killable';
import { lookup as mimeTypeLookup } from 'mime-types';
import { basename } from 'path';
import { parse as qsParse } from 'qs';
import { xml2js } from 'xml-js';
import { ParsedXMLBodyMimeTypes } from '../../constants/common.constants';
import { DefaultTLSOptions } from '../../constants/ssl.constants';
import { ResponseRulesInterpreter } from '../response-rules-interpreter';
import { TemplateParser } from '../template-parser';
import { requestHelperNames } from '../templating-helpers/request-helpers';
import { CreateTransaction, dedupSlashes, resolvePathFromEnvironment, routesFromFolder, stringIncludesArrayItems } from '../utils';
import { crudRoutesBuilder, databucketActions } from './crud';
/**
 * Create a server instance from an Environment object.
 *
 * Extends EventEmitter.
 */
export class MockoonServer extends EventEmitter {
    constructor(environment, options = {}) {
        super();
        this.environment = environment;
        this.options = options;
        this.tlsOptions = {};
        this.processedDatabuckets = [];
        /**
         * ### Middleware ###
         * Emit the SERVER_ENTERING_REQUEST event
         *
         * @param request
         * @param response
         * @param next
         */
        this.emitEvent = (request, response, next) => {
            this.emit('entering-request');
            next();
        };
        /**
         * ### Middleware ###
         * Add global latency to the mock server
         *
         * @param request
         * @param response
         * @param next
         */
        this.delayResponse = (request, response, next) => {
            this.refreshEnvironment();
            setTimeout(next, this.environment.latency);
        };
        /**
         * ### Middleware ###
         * Parse entering request body
         *
         * @param request
         * @param response
         * @param next
         */
        this.parseBody = (request, response, next) => {
            // Parse body as a raw string and JSON/form if applicable
            const requestContentType = request.header('Content-Type');
            const rawBody = [];
            request.on('data', (chunk) => {
                rawBody.push(Buffer.from(chunk, 'binary'));
            });
            request.on('end', () => {
                request.rawBody = Buffer.concat(rawBody);
                request.stringBody = request.rawBody.toString('utf8');
                try {
                    if (requestContentType) {
                        if (requestContentType.includes('application/json')) {
                            request.body = JSON.parse(request.stringBody);
                            next();
                        }
                        else if (requestContentType.includes('application/x-www-form-urlencoded')) {
                            request.body = qsParse(request.stringBody, {
                                depth: 10
                            });
                            next();
                        }
                        else if (requestContentType.includes('multipart/form-data')) {
                            const busboyParse = busboy({
                                headers: request.headers,
                                limits: { fieldNameSize: 1000, files: 0 }
                            });
                            busboyParse.on('field', (name, value, info) => {
                                if (request.body === undefined) {
                                    request.body = {};
                                }
                                if (name != null && !info.nameTruncated && !info.valueTruncated) {
                                    appendField(request.body, name, value);
                                }
                            });
                            busboyParse.on('error', (error) => {
                                this.emit('error', ServerErrorCodes.REQUEST_BODY_PARSE, error);
                                // we want to continue answering the call despite the parsing errors
                                next();
                            });
                            busboyParse.on('finish', () => {
                                next();
                            });
                            busboyParse.end(request.rawBody);
                        }
                        else if (stringIncludesArrayItems(ParsedXMLBodyMimeTypes, requestContentType)) {
                            request.body = xml2js(request.stringBody, {
                                compact: true
                            });
                            next();
                        }
                        else {
                            next();
                        }
                    }
                    else {
                        next();
                    }
                }
                catch (error) {
                    this.emit('error', ServerErrorCodes.REQUEST_BODY_PARSE, error);
                    next();
                }
            });
        };
        /**
         * ### Middleware ###
         * Emit an event when response emit the 'close' event
         *
         * @param request
         * @param response
         * @param next
         */
        this.logRequest = (request, response, next) => {
            response.on('close', () => {
                this.emit('transaction-complete', CreateTransaction(request, response));
            });
            next();
        };
        /**
         * ### Middleware ###
         * Add environment headers & proxy headers to the response
         *
         * @param request
         * @param response
         * @param next
         */
        this.setResponseHeaders = (request, response, next) => {
            this.setHeaders(this.environment.headers, response, request);
            next();
        };
        /**
         * ### Middleware ###
         * Catch all error handler
         * http://expressjs.com/en/guide/error-handling.html#catching-errors
         *
         * @param server - server on which to log the response
         */
        this.errorHandler = (error, request, response, next) => {
            this.sendError(response, error, 500);
        };
    }
    /**
     * Start a server
     */
    start() {
        const requestListener = this.createRequestListener();
        // create https or http server instance
        if (this.environment.tlsOptions.enabled) {
            try {
                this.tlsOptions = this.buildTLSOptions(this.environment);
                this.serverInstance = httpsCreateServer(this.tlsOptions, requestListener);
            }
            catch (error) {
                if (error.code === 'ENOENT') {
                    this.emit('error', ServerErrorCodes.CERT_FILE_NOT_FOUND, error);
                }
                else {
                    this.emit('error', ServerErrorCodes.UNKNOWN_SERVER_ERROR, error);
                }
            }
        }
        else {
            this.serverInstance = httpCreateServer(requestListener);
        }
        // make serverInstance killable
        this.serverInstance = killable(this.serverInstance);
        // set timeout long enough to allow long latencies
        this.serverInstance.setTimeout(3600000);
        // handle server errors
        this.serverInstance.on('error', (error) => {
            let errorCode;
            switch (error.code) {
                case 'EADDRINUSE':
                    errorCode = ServerErrorCodes.PORT_ALREADY_USED;
                    break;
                case 'EACCES':
                    errorCode = ServerErrorCodes.PORT_INVALID;
                    break;
                case 'EADDRNOTAVAIL':
                    errorCode = ServerErrorCodes.HOSTNAME_UNAVAILABLE;
                    break;
                case 'ENOTFOUND':
                    errorCode = ServerErrorCodes.HOSTNAME_UNKNOWN;
                    break;
                default:
                    errorCode = ServerErrorCodes.UNKNOWN_SERVER_ERROR;
            }
            this.emit('error', errorCode, error);
        });
        this.serverInstance.listen({ port: this.environment.port, host: this.environment.hostname }, () => {
            this.emit('started');
        });
    }
    /**
     * Kill the server
     */
    stop() {
        if (this.serverInstance) {
            this.serverInstance.kill(() => {
                this.emit('stopped');
            });
        }
    }
    /**
     * Create a request listener
     */
    createRequestListener() {
        const app = express();
        app.disable('x-powered-by');
        app.disable('etag');
        this.generateDatabuckets(this.environment);
        app.use(this.emitEvent);
        app.use(this.delayResponse);
        app.use(this.deduplicateRequestSlashes);
        app.use(cookieParser());
        app.use(this.parseBody);
        app.use(this.logRequest);
        app.use(this.setResponseHeaders);
        this.setRoutes(app);
        this.setCors(app);
        this.enableProxy(app);
        app.use(this.errorHandler);
        return app;
    }
    /**
     * ### Middleware ###
     * Remove duplicate slashes in entering call paths
     *
     * @param request
     * @param response
     * @param next
     */
    deduplicateRequestSlashes(request, response, next) {
        request.url = dedupSlashes(request.url);
        next();
    }
    /**
     * Generate an environment routes and attach to running server
     *
     * @param server - server on which attach routes
     */
    setRoutes(server) {
        if (!this.environment.rootChildren ||
            this.environment.rootChildren.length < 1) {
            return;
        }
        const routes = routesFromFolder(this.environment.rootChildren, this.environment.folders, this.environment.routes);
        routes.forEach((declaredRoute) => {
            // only launch non duplicated routes, or ignore if none.
            if (declaredRoute.enabled) {
                try {
                    let routePath = `/${this.environment.endpointPrefix}/${declaredRoute.endpoint.replace(/ /g, '%20')}`;
                    routePath = dedupSlashes(routePath);
                    if (declaredRoute.type === RouteType.CRUD) {
                        this.createCRUDRoute(server, declaredRoute, routePath);
                    }
                    else {
                        this.createRESTRoute(server, declaredRoute, routePath);
                    }
                }
                catch (error) {
                    let errorCode = ServerErrorCodes.ROUTE_CREATION_ERROR;
                    // if invalid regex defined
                    if (error.message.indexOf('Invalid regular expression') > -1) {
                        errorCode = ServerErrorCodes.ROUTE_CREATION_ERROR_REGEX;
                    }
                    this.emit('error', errorCode, error);
                }
            }
        });
    }
    /**
     * Create a regular REST route (GET, POST, etc.)
     *
     * @param server
     * @param route
     * @param routePath
     */
    createRESTRoute(server, route, routePath) {
        server[route.method](routePath, this.createRouteHandler(route, 1));
    }
    /**
     * Create a CRUD route: GET, POST, PUT, PATCH, DELETE
     *
     * @param server
     * @param route
     * @param routePath
     */
    createCRUDRoute(server, route, routePath) {
        const crudRoutes = crudRoutesBuilder(routePath);
        for (const crudRoute of crudRoutes) {
            server[crudRoute.method](crudRoute.path, this.createRouteHandler(route, 1, crudRoute.id));
        }
    }
    createRouteHandler(route, requestNumber, crudId) {
        return (request, response) => {
            this.generateRequestDatabuckets(route, this.environment, request);
            // refresh environment data to get route changes that do not require a restart (headers, body, etc)
            this.refreshEnvironment();
            const currentRoute = this.getRefreshedRoute(route);
            if (!currentRoute) {
                this.sendError(response, CommonsTexts.EN.MESSAGES.ROUTE_NO_LONGER_EXISTS, 404);
                return;
            }
            const enabledRouteResponse = new ResponseRulesInterpreter(currentRoute.responses, request, currentRoute.responseMode).chooseResponse(requestNumber);
            requestNumber += 1;
            // save route and response UUIDs for logs (only in desktop app)
            if (route.uuid && enabledRouteResponse.uuid) {
                response.routeUUID = route.uuid;
                response.routeResponseUUID = enabledRouteResponse.uuid;
            }
            // add route latency if any
            setTimeout(() => {
                const contentType = GetRouteResponseContentType(this.environment, enabledRouteResponse);
                const routeContentType = GetContentType(enabledRouteResponse.headers);
                // set http code
                response.status(enabledRouteResponse.statusCode);
                this.setHeaders(enabledRouteResponse.headers, response, request);
                // send the file
                if (enabledRouteResponse.bodyType === BodyTypes.FILE &&
                    enabledRouteResponse.filePath) {
                    this.sendFile(enabledRouteResponse, routeContentType, request, response);
                    // serve inline body or databucket
                }
                else {
                    let templateParse = true;
                    if (contentType.includes('application/json')) {
                        response.set('Content-Type', 'application/json');
                    }
                    // serve inline body as default
                    let content = enabledRouteResponse.body;
                    if (enabledRouteResponse.bodyType === BodyTypes.DATABUCKET &&
                        enabledRouteResponse.databucketID) {
                        // databuckets are parsed at the server start or beginning of first request execution (no need to parse templating again)
                        templateParse = false;
                        const servedDatabucket = this.processedDatabuckets.find((processedDatabucket) => processedDatabucket.id === enabledRouteResponse.databucketID);
                        if (servedDatabucket) {
                            content = servedDatabucket.value;
                            if (route.type === RouteType.CRUD && crudId) {
                                content = databucketActions(crudId, servedDatabucket, request, response);
                            }
                            // if returned content is an array or object we need to stringify it for some values (array, object, booleans and numbers (bool and nb because expressjs cannot serve this as is))
                            if (Array.isArray(content) ||
                                typeof content === 'object' ||
                                typeof content === 'boolean' ||
                                typeof content === 'number') {
                                content = JSON.stringify(content);
                            }
                            else {
                                content = content;
                            }
                        }
                    }
                    this.serveBody(content || '', enabledRouteResponse, request, response, templateParse);
                }
            }, enabledRouteResponse.latency);
        };
    }
    /**
     * Parse the body templating and send it as the response body
     *
     * @param routeResponse
     * @param request
     * @param response
     */
    serveBody(content, routeResponse, request, response, templateParse = true) {
        try {
            if (!routeResponse.disableTemplating && templateParse) {
                content = TemplateParser(false, content || '', this.environment, this.processedDatabuckets, request, response);
            }
            this.applyResponseLocals(response);
            response.body = content;
            response.send(content);
        }
        catch (error) {
            this.emit('error', ServerErrorCodes.ROUTE_SERVING_ERROR, error);
            this.sendError(response, `${CommonsTexts.EN.MESSAGES.ROUTE_SERVING_ERROR}: ${error.message}`);
        }
    }
    /**
     * Send a file as response body.
     * Revert to sendBody if file is not found.
     *
     * @param routeResponse
     * @param routeContentType
     * @param request
     * @param response
     */
    sendFile(routeResponse, routeContentType, request, response) {
        const fileServingError = (error) => {
            this.emit('error', ServerErrorCodes.ROUTE_FILE_SERVING_ERROR, error);
            this.sendError(response, `${CommonsTexts.EN.MESSAGES.ROUTE_FILE_SERVING_ERROR}: ${error.message}`);
        };
        const errorThrowOrFallback = (error) => {
            if (routeResponse.fallbackTo404) {
                response.status(404);
                const content = routeResponse.body ? routeResponse.body : '';
                this.serveBody(content, routeResponse, request, response);
            }
            else {
                fileServingError(error);
            }
        };
        try {
            let filePath = TemplateParser(false, routeResponse.filePath.replace(/\\/g, '/'), this.environment, this.processedDatabuckets, request);
            filePath = resolvePathFromEnvironment(filePath, this.options.environmentDirectory);
            const fileMimeType = mimeTypeLookup(filePath) || '';
            // set content-type the detected mime type if any
            if (!routeContentType && fileMimeType) {
                response.set('Content-Type', fileMimeType);
            }
            if (!routeResponse.sendFileAsBody) {
                response.set('Content-Disposition', `attachment; filename="${basename(filePath)}"`);
            }
            // parse templating for a limited list of mime types
            if (MimeTypesWithTemplating.indexOf(fileMimeType) > -1 &&
                !routeResponse.disableTemplating) {
                readFile(filePath, (readError, data) => {
                    if (readError) {
                        errorThrowOrFallback(readError);
                        return;
                    }
                    try {
                        const fileContent = TemplateParser(false, data.toString(), this.environment, this.processedDatabuckets, request, response);
                        this.applyResponseLocals(response);
                        response.body = fileContent;
                        response.send(fileContent);
                    }
                    catch (error) {
                        fileServingError(error);
                    }
                });
            }
            else {
                try {
                    response.body = BINARY_BODY;
                    const { size } = statSync(filePath);
                    this.setHeaders([
                        {
                            key: 'Content-Length',
                            value: size.toString()
                        }
                    ], response, request);
                    // use read stream for better performance
                    createReadStream(filePath).pipe(response);
                }
                catch (error) {
                    errorThrowOrFallback(error);
                }
            }
        }
        catch (error) {
            this.emit('error', ServerErrorCodes.ROUTE_SERVING_ERROR, error);
            this.sendError(response, `${CommonsTexts.EN.MESSAGES.ROUTE_SERVING_ERROR}: ${error.message}`);
        }
    }
    /**
     * Always answer with status 200 to CORS pre flight OPTIONS requests if option activated.
     * /!\ Must be called after the routes creation otherwise it will intercept all user defined OPTIONS routes.
     *
     * @param server - express instance
     */
    setCors(server) {
        if (this.environment.cors) {
            server.options('/*', (req, res) => {
                this.refreshEnvironment();
                // override default CORS headers with environment's headers
                this.setHeaders([...CORSHeaders, ...this.environment.headers], res, req);
                res.status(200).end();
            });
        }
    }
    /**
     * Add catch-all proxy if enabled.
     * Restream the body to the proxied API because it already has been
     * intercepted by the body parser.
     *
     * @param server - server on which to launch the proxy
     */
    enableProxy(server) {
        if (this.environment.proxyMode &&
            this.environment.proxyHost &&
            IsValidURL(this.environment.proxyHost)) {
            this.emit('creating-proxy');
            server.use('*', createProxyMiddleware({
                cookieDomainRewrite: { '*': '' },
                target: this.environment.proxyHost,
                secure: false,
                changeOrigin: true,
                logProvider: this.options.logProvider,
                pathRewrite: (path, req) => {
                    if (this.environment.proxyRemovePrefix === true &&
                        this.environment.endpointPrefix.length > 0) {
                        const regExp = new RegExp(`^/${this.environment.endpointPrefix}`);
                        return path.replace(regExp, '');
                    }
                    return path;
                },
                ssl: Object.assign(Object.assign({}, this.tlsOptions), { agent: false }),
                onProxyReq: (proxyReq, request, response) => {
                    this.refreshEnvironment();
                    request.proxied = true;
                    this.setHeaders(this.environment.proxyReqHeaders, proxyReq, request);
                    // re-stream the body (intercepted by body parser method)
                    if (request.rawBody) {
                        proxyReq.write(request.rawBody);
                    }
                },
                onProxyRes: (proxyRes, request, response) => {
                    this.refreshEnvironment();
                    const buffers = [];
                    proxyRes.on('data', (chunk) => {
                        buffers.push(chunk);
                    });
                    proxyRes.on('end', () => {
                        response.body = Buffer.concat(buffers);
                    });
                    this.setHeaders(this.environment.proxyResHeaders, proxyRes, request);
                },
                onError: (error, request, response) => {
                    this.emit('error', ServerErrorCodes.PROXY_ERROR, error);
                    this.sendError(response, `${CommonsTexts.EN.MESSAGES.PROXY_ERROR}${this.environment.proxyHost}${request.url}: ${error}`, 504);
                }
            }));
        }
    }
    /**
     * Set the provided headers on the target. Use different headers accessors
     * depending on the type of target:
     * express.Response/http.OutgoingMessage/http.IncomingMessage
     * Use the source in the template parsing of each header value.
     *
     * @param headers
     * @param target
     * @param request
     */
    setHeaders(headers, target, request) {
        headers.forEach((header) => {
            try {
                const isSetCookie = header.key.toLowerCase() === 'set-cookie';
                let parsedHeaderValue = this.parseHeader(header, request);
                if (parsedHeaderValue === null) {
                    return;
                }
                if (target.set) {
                    // for express.Response
                    if (isSetCookie) {
                        target.append(header.key, parsedHeaderValue);
                    }
                    else {
                        target.set(header.key, parsedHeaderValue);
                    }
                }
                else if (target.setHeader) {
                    // for proxy http.OutgoingMessage | ClientRequest
                    target.setHeader(header.key, parsedHeaderValue);
                }
                else {
                    // for http.IncomingMessage
                    if (isSetCookie) {
                        // Remove the secure flag
                        parsedHeaderValue = parsedHeaderValue.replace(/; secure/gi, '');
                        target.headers[header.key] = this.appendHeaderValue(target.headers[header.key], parsedHeaderValue);
                    }
                    else {
                        target.headers[header.key] = parsedHeaderValue;
                    }
                }
            }
            catch (error) { }
        });
    }
    /**
     * If header already has a value, concatenate the values into an array
     *
     * @param currentValue
     * @param newValue
     * @returns
     */
    appendHeaderValue(currentValue, newValue) {
        let headerValue = newValue;
        if (currentValue) {
            headerValue = Array.isArray(currentValue)
                ? currentValue.concat(headerValue)
                : [currentValue, headerValue];
        }
        return headerValue;
    }
    /**
     * Verify a header validity and parse its content, if templating is used
     *
     * @param header
     * @param request
     * @returns
     */
    parseHeader(header, request) {
        let parsedHeaderValue = null;
        if (header.key && header.value) {
            try {
                parsedHeaderValue = TemplateParser(false, header.value, this.environment, this.processedDatabuckets, request);
            }
            catch (error) {
                const errorMessage = CommonsTexts.EN.MESSAGES.HEADER_PARSING_ERROR;
                parsedHeaderValue = errorMessage;
            }
        }
        return parsedHeaderValue;
    }
    /**
     * Send an error with text/plain content type, the provided message and status code.
     * Status is optional. No status will default to the one defined by the user, allowing for maximum customization.
     *
     * @param response
     * @param errorMessage
     * @param status
     */
    sendError(response, errorMessage, status) {
        response.set('Content-Type', 'text/plain');
        response.body = errorMessage;
        if (errorMessage instanceof Error) {
            errorMessage = errorMessage.message;
        }
        if (status !== undefined) {
            response.status(status);
        }
        response.send(errorMessage);
    }
    /**
     * Request an updated environment to allow
     * modification of some parameters without a restart (latency, headers, etc)
     */
    refreshEnvironment() {
        if (this.options.refreshEnvironmentFunction && this.environment.uuid) {
            const updatedEnvironment = this.options.refreshEnvironmentFunction(this.environment.uuid);
            if (updatedEnvironment) {
                this.environment = updatedEnvironment;
            }
        }
    }
    /**
     * Request an updated route to allow
     * modification of some parameters without a restart (latency, headers, etc)
     * This only makes sense if the refreshEnvironmentFunction has been provided.
     *
     * @param routeUUID
     */
    getRefreshedRoute(currentRoute) {
        if (this.options.refreshEnvironmentFunction && this.environment.uuid) {
            return this.environment.routes.find((route) => route.uuid === currentRoute.uuid);
        }
        return currentRoute;
    }
    /**
     * Build the secure context options
     * - if custom cert are provided load them
     * - if not, use default TLS cert (self-signed)
     *
     * @returns
     */
    buildTLSOptions(environment) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        let tlsOptions = {};
        if (((_a = environment.tlsOptions) === null || _a === void 0 ? void 0 : _a.pfxPath) ||
            (((_b = environment.tlsOptions) === null || _b === void 0 ? void 0 : _b.certPath) && ((_c = environment.tlsOptions) === null || _c === void 0 ? void 0 : _c.keyPath))) {
            if (((_d = environment.tlsOptions) === null || _d === void 0 ? void 0 : _d.type) === 'PFX' &&
                ((_e = environment.tlsOptions) === null || _e === void 0 ? void 0 : _e.pfxPath)) {
                tlsOptions.pfx = readFileSync(resolvePathFromEnvironment((_f = environment.tlsOptions) === null || _f === void 0 ? void 0 : _f.pfxPath, this.options.environmentDirectory));
            }
            else if (((_g = environment.tlsOptions) === null || _g === void 0 ? void 0 : _g.type) === 'CERT' &&
                ((_h = environment.tlsOptions) === null || _h === void 0 ? void 0 : _h.certPath) &&
                ((_j = environment.tlsOptions) === null || _j === void 0 ? void 0 : _j.keyPath)) {
                tlsOptions.cert = readFileSync(resolvePathFromEnvironment((_k = environment.tlsOptions) === null || _k === void 0 ? void 0 : _k.certPath, this.options.environmentDirectory));
                tlsOptions.key = readFileSync(resolvePathFromEnvironment((_l = environment.tlsOptions) === null || _l === void 0 ? void 0 : _l.keyPath, this.options.environmentDirectory));
            }
            if ((_m = environment.tlsOptions) === null || _m === void 0 ? void 0 : _m.caPath) {
                tlsOptions.ca = readFileSync(resolvePathFromEnvironment((_o = environment.tlsOptions) === null || _o === void 0 ? void 0 : _o.caPath, this.options.environmentDirectory));
            }
            if ((_p = environment.tlsOptions) === null || _p === void 0 ? void 0 : _p.passphrase) {
                tlsOptions.passphrase = (_q = environment.tlsOptions) === null || _q === void 0 ? void 0 : _q.passphrase;
            }
        }
        else {
            tlsOptions = Object.assign({}, DefaultTLSOptions);
        }
        return tlsOptions;
    }
    /**
     * Parse all databuckets in the environment and set their parsed value to true except if they contain request helpers
     * @param environment
     */
    generateDatabuckets(environment) {
        if (environment.data.length > 0) {
            environment.data.forEach((databucket) => {
                let newProcessedDatabucket;
                if (databucket.value.match(new RegExp(`{{2,3}[#(\\s\\w]*(${requestHelperNames.join('|')})`))) {
                    // a request helper was found
                    newProcessedDatabucket = {
                        id: databucket.id,
                        name: databucket.name,
                        value: databucket.value,
                        parsed: false
                    };
                }
                else {
                    let templateParsedContent;
                    try {
                        templateParsedContent = TemplateParser(false, databucket.value, environment, this.processedDatabuckets);
                        const JSONParsedContent = JSON.parse(templateParsedContent);
                        newProcessedDatabucket = {
                            id: databucket.id,
                            name: databucket.name,
                            value: JSONParsedContent,
                            parsed: true
                        };
                    }
                    catch (error) {
                        if (error instanceof SyntaxError) {
                            newProcessedDatabucket = {
                                id: databucket.id,
                                name: databucket.name,
                                value: templateParsedContent,
                                parsed: true
                            };
                        }
                        else {
                            newProcessedDatabucket = {
                                id: databucket.id,
                                name: databucket.name,
                                value: error.message,
                                parsed: true
                            };
                        }
                    }
                }
                this.processedDatabuckets.push(newProcessedDatabucket);
            });
        }
    }
    /**
     * Generate the databuckets called with the data helper on route call
     * @param route
     * @param environment
     * @param request
     */
    generateRequestDatabuckets(route, environment, request) {
        // do not continue if all the buckets were previously parsed
        if (!this.processedDatabuckets.some((processedDatabucket) => !processedDatabucket.parsed)) {
            return;
        }
        route.responses.forEach((response) => {
            var _a;
            const results = (_a = response.body) === null || _a === void 0 ? void 0 : _a.matchAll(new RegExp('{{2,3}[#(\\s\\w]*data [\'|"]{1}([^(\'|")]*)', 'g'));
            const databucketIdsToParse = new Set([...(results || [])].map((match) => match[1]));
            if (response.databucketID) {
                databucketIdsToParse.add(response.databucketID);
            }
            if (databucketIdsToParse.size > 0) {
                let targetDatabucket;
                for (const databucketIdToParse of databucketIdsToParse) {
                    targetDatabucket = this.processedDatabuckets.find((databucket) => databucket.id === databucketIdToParse ||
                        databucket.name
                            .toLowerCase()
                            .includes(databucketIdToParse.toLowerCase()));
                    if (targetDatabucket && !(targetDatabucket === null || targetDatabucket === void 0 ? void 0 : targetDatabucket.parsed)) {
                        let content = targetDatabucket.value;
                        try {
                            content = TemplateParser(false, targetDatabucket.value, environment, this.processedDatabuckets, request);
                            const JSONParsedcontent = JSON.parse(content);
                            targetDatabucket.value = JSONParsedcontent;
                            targetDatabucket.parsed = true;
                        }
                        catch (error) {
                            if (error instanceof SyntaxError) {
                                targetDatabucket.value = content;
                            }
                            else {
                                targetDatabucket.value = error.message;
                            }
                            targetDatabucket.parsed = true;
                        }
                    }
                }
            }
        });
    }
    /**
     * Set response properties from the locals object.
     * Currently supports the statusCode that can be set using templating helper.
     *
     * @param response
     */
    applyResponseLocals(response) {
        if (response.locals.statusCode !== undefined) {
            response.status(response.locals.statusCode);
        }
    }
}
//# sourceMappingURL=server.js.map